<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/security-module.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/security-module.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Security Module
 * Handles all security-related automation tasks
 */

const { BaseModule } = require('../core/framework');
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');

const execAsync = promisify(exec);

class SecurityModule extends BaseModule {
  constructor(framework) {
    super(framework);
    this.name = 'SecurityModule';

    // Register module tasks
    this.registerTask('scan-secrets', this.scanSecrets);
    this.registerTask('audit-dependencies', this.auditDependencies);
    this.registerTask('check-vulnerabilities', this.checkVulnerabilities);
    this.registerTask('scan-containers', this.scanContainers);
    this.registerTask('validate-permissions', this.validatePermissions);
    this.registerTask('compliance-check', this.complianceCheck);
  }

  /**
   * Scan for secrets in codebase
   * @param {{targetDir?:string}} params Target directory to scan
   * @returns {Promise&lt;{timestamp:string,secretsFound:Array,filesScanned:number,status:string,reportPath?:string,error?:string}>}
   */
  async scanSecrets(params = {}) {
    this.logger.info('Starting secret scanning');

    const results = {
      timestamp: new Date().toISOString(),
      secretsFound: [],
      filesScanned: 0,
      status: 'success',
    };

    try {
      // Check if gitleaks is available
      const { stdout: gitleaksVersion } = await execAsync('gitleaks version').catch(() => ({
        stdout: null,
      }));

      if (gitleaksVersion) {
        this.logger.info('Running Gitleaks scan');
        const { stdout, stderr } = await execAsync(
          'gitleaks detect --source . --verbose --redact --no-git'
        );

        if (stderr &amp;&amp; stderr.includes('leak')) {
          results.secretsFound.push({
            tool: 'gitleaks',
            findings: stderr,
          });
          results.status = 'warning';
        }
      } else {
        this.logger.warn('Gitleaks not installed, using pattern-based scanning');

        // Fallback pattern-based scanning
        const patterns = [
          { name: 'AWS Key', pattern: /AKIA[0-9A-Z]{16}/g },
          { name: 'GitHub Token', pattern: /ghp_[0-9a-zA-Z]{36}/g },
          {
            name: 'Generic Secret',
            pattern: /(api[_-]?key|secret|token|password)\s*=\s*['""][^'"]{8,}/gi,
          },
          { name: 'Private Key', pattern: /-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----/g },
          { name: 'Stripe Key', pattern: /sk_live_[0-9a-zA-Z]{24}/g },
        ];

        const exclusions = ['node_modules', '.git', 'dist', 'build', '.automation'];

        const scanDirectory = async dir => {
          const entries = await fs.readdir(dir, { withFileTypes: true });

          for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (exclusions.some(ex => fullPath.includes(ex))) continue;

            if (entry.isDirectory()) {
              await scanDirectory(fullPath);
            } else if (entry.isFile()) {
              results.filesScanned++;
              const content = await fs.readFile(fullPath, 'utf8').catch(() => null);

              if (content) {
                for (const { name, pattern } of patterns) {
                  const matches = content.match(pattern);
                  if (matches) {
                    results.secretsFound.push({
                      file: fullPath,
                      pattern: name,
                      count: matches.length,
                    });
                  }
                }
              }
            }
          }
        };

        await scanDirectory(params.targetDir || '.');
      }

      // Generate report
      if (results.secretsFound.length > 0) {
        this.logger.warn(`Found ${results.secretsFound.length} potential secrets`);
        results.status = 'warning';

        // Save report
        const reportPath = path.join(
          this.framework.config.logDir,
          `security-scan-${Date.now()}.json`
        );
        await fs.writeFile(reportPath, JSON.stringify(results, null, 2));
        results.reportPath = reportPath;
      } else {
        this.logger.info('No secrets detected');
      }
    } catch (error) {
      this.logger.error('Secret scanning failed', { error: error.message });
      results.status = 'failed';
      results.error = error.message;
    }

    return results;
  }

  /**
   * Audit dependencies for vulnerabilities
   * @param {{autoFix?:boolean}} params Auto-fix vulnerabilities if possible
   * @returns {Promise&lt;{timestamp:string,vulnerabilities:object,status:string,error?:string}>}
   */
  async auditDependencies(params = {}) {
    this.logger.info('Starting dependency audit');

    const results = {
      timestamp: new Date().toISOString(),
      vulnerabilities: {
        critical: 0,
        high: 0,
        moderate: 0,
        low: 0,
      },
      status: 'success',
    };

    try {
      // Run pnpm audit
      const { stdout } = await execAsync('pnpm audit --json').catch(e => ({ stdout: e.stdout }));

      if (stdout) {
        try {
          const auditData = JSON.parse(stdout);

          if (auditData.advisories) {
            Object.values(auditData.advisories).forEach(advisory => {
              const severity = advisory.severity.toLowerCase();
              if (results.vulnerabilities[severity] !== undefined) {
                results.vulnerabilities[severity]++;
              }
            });
          }
        } catch (parseError) {
          this.logger.warn('Could not parse audit output');
        }
      }

      // Check for critical vulnerabilities
      if (results.vulnerabilities.critical > 0 || results.vulnerabilities.high > 0) {
        results.status = 'critical';
        this.logger.error('Critical or high vulnerabilities found', results.vulnerabilities);
      } else if (results.vulnerabilities.moderate > 0) {
        results.status = 'warning';
        this.logger.warn('Moderate vulnerabilities found', results.vulnerabilities);
      }

      // Try to auto-fix if requested
      if (params.autoFix &amp;&amp; results.status !== 'success') {
        this.logger.info('Attempting to auto-fix vulnerabilities');
        await execAsync('pnpm audit fix').catch(() => {
          this.logger.warn('Auto-fix failed, manual intervention required');
        });
      }
    } catch (error) {
      this.logger.error('Dependency audit failed', { error: error.message });
      results.status = 'failed';
      results.error = error.message;
    }

    return results;
  }

  /**
   * Check for code vulnerabilities
   * @param {{targetDir?:string}} params Directory to scan
   * @returns {Promise&lt;{timestamp:string,vulnerabilities:Array,status:string,error?:string}>}
   */
  async checkVulnerabilities(params = {}) {
    this.logger.info('Checking code vulnerabilities');

    const results = {
      timestamp: new Date().toISOString(),
      vulnerabilities: [],
      status: 'success',
    };

    const checks = [
      {
        name: 'eval() usage',
        pattern: /\beval\s*\(/g,
        severity: 'high',
        message: 'eval() can execute arbitrary code',
      },
      {
        name: 'innerHTML usage',
        pattern: /\.innerHTML\s*=/g,
        severity: 'medium',
        message: 'innerHTML can lead to XSS vulnerabilities',
      },
      {
        name: 'SQL concatenation',
        pattern: /SELECT.*\+|INSERT.*\+|UPDATE.*\+|DELETE.*\+/gi,
        severity: 'high',
        message: 'Potential SQL injection vulnerability',
      },
      {
        name: 'Hardcoded credentials',
        pattern: /(password|secret|api_key)\s*=\s*["'][^"']{8,}/gi,
        severity: 'critical',
        message: 'Hardcoded credentials detected',
      },
    ];

    try {
      const scanFile = async filePath => {
        const content = await fs.readFile(filePath, 'utf8').catch(() => null);
        if (!content) return;

        for (const check of checks) {
          const matches = content.match(check.pattern);
          if (matches) {
            results.vulnerabilities.push({
              file: filePath,
              check: check.name,
              severity: check.severity,
              message: check.message,
              occurrences: matches.length,
            });
          }
        }
      };

      // Scan source files
      const sourcePatterns = ['**/*.js', '**/*.ts', '**/*.jsx', '**/*.tsx'];

      // Simple file scanning (in production, use glob library)
      const scanDir = async dir => {
        const entries = await fs.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);

          if (entry.isDirectory() &amp;&amp; !['node_modules', '.git', 'dist'].includes(entry.name)) {
            await scanDir(fullPath);
          } else if (entry.isFile() &amp;&amp; /\.(js|ts|jsx|tsx)$/.test(entry.name)) {
            await scanFile(fullPath);
          }
        }
      };

      await scanDir(params.targetDir || '.');

      // Evaluate overall status
      const criticalCount = results.vulnerabilities.filter(v => v.severity === 'critical').length;
      const highCount = results.vulnerabilities.filter(v => v.severity === 'high').length;

      if (criticalCount > 0) {
        results.status = 'critical';
        this.logger.error(`Found ${criticalCount} critical vulnerabilities`);
      } else if (highCount > 0) {
        results.status = 'warning';
        this.logger.warn(`Found ${highCount} high severity vulnerabilities`);
      }
    } catch (error) {
      this.logger.error('Vulnerability check failed', { error: error.message });
      results.status = 'failed';
      results.error = error.message;
    }

    return results;
  }

  /**
   * Scan container images for vulnerabilities
   * @param {{}} params Reserved
   * @returns {Promise&lt;{timestamp:string,images:Array,status:string,error?:string}>}
   */
  async scanContainers(params = {}) {
    this.logger.info('Scanning container images');

    const results = {
      timestamp: new Date().toISOString(),
      images: [],
      status: 'success',
    };

    try {
      // Check if Docker is available
      await execAsync('docker --version');

      // Get list of images
      const { stdout: imageList } = await execAsync(
        'docker images --format "{{.Repository}}:{{.Tag}}"'
      );
      const images = imageList
        .trim()
        .split('\n')
        .filter(img => img &amp;&amp; !img.includes('&lt;none>'));

      for (const image of images) {
        this.logger.info(`Scanning image: ${image}`);

        // Try Trivy if available
        const trivyResult = await execAsync(
          `trivy image --severity HIGH,CRITICAL --format json ${image}`
        ).catch(() => null);

        if (trivyResult &amp;&amp; trivyResult.stdout) {
          try {
            const scanData = JSON.parse(trivyResult.stdout);
            results.images.push({
              image,
              tool: 'trivy',
              vulnerabilities: scanData.Results || [],
              scanned: true,
            });
          } catch (e) {
            this.logger.warn(`Could not parse Trivy results for ${image}`);
          }
        } else {
          // Fallback: basic checks
          const { stdout: history } = await execAsync(`docker history ${image} --no-trunc`);

          results.images.push({
            image,
            tool: 'basic',
            checks: {
              hasUser: !history.includes('USER root'),
              hasHealthcheck: history.includes('HEALTHCHECK'),
              size: await this.getImageSize(image),
            },
            scanned: true,
          });
        }
      }
    } catch (error) {
      if (error.message.includes('docker: command not found')) {
        this.logger.info('Docker not available, skipping container scanning');
      } else {
        this.logger.error('Container scanning failed', { error: error.message });
        results.status = 'failed';
        results.error = error.message;
      }
    }

    return results;
  }

  /**
   * Validate file permissions
   * @param {{}} params Reserved
   * @returns {Promise&lt;{timestamp:string,issues:Array,status:string,error?:string}>}
   */
  async validatePermissions(params = {}) {
    this.logger.info('Validating file permissions');

    const results = {
      timestamp: new Date().toISOString(),
      issues: [],
      status: 'success',
    };

    try {
      // Check for overly permissive files (Unix-like systems only)
      if (process.platform !== 'win32') {
        const { stdout } = await execAsync(
          'find . -type f -perm -002 ! -path "./node_modules/*" ! -path "./.git/*"'
        ).catch(() => ({ stdout: '' }));

        if (stdout) {
          const files = stdout.trim().split('\n').filter(Boolean);
          if (files.length > 0) {
            results.issues.push({
              type: 'world-writable',
              files,
              severity: 'high',
              recommendation: 'Remove world-writable permissions',
            });
            results.status = 'warning';
          }
        }
      }

      // Check for sensitive files
      const sensitivePatterns = ['.env', '*.key', '*.pem', 'credentials.json', 'secrets.*'];

      for (const pattern of sensitivePatterns) {
        const files = await this.findFiles(pattern);

        if (files.length > 0) {
          // Check if they're gitignored
          for (const file of files) {
            const isGitignored = await this.isFileGitignored(file);

            if (!isGitignored) {
              results.issues.push({
                type: 'sensitive-file-exposed',
                file,
                severity: 'critical',
                recommendation: 'Add to .gitignore immediately',
              });
              results.status = 'critical';
            }
          }
        }
      }
    } catch (error) {
      this.logger.error('Permission validation failed', { error: error.message });
      results.status = 'failed';
      results.error = error.message;
    }

    return results;
  }

  /**
   * Run compliance checks
   * @param {{}} params Reserved
   * @returns {Promise&lt;{timestamp:string,compliance:object,status:string,error?:string}>}
   */
  async complianceCheck(params = {}) {
    this.logger.info('Running compliance checks');

    const results = {
      timestamp: new Date().toISOString(),
      compliance: {
        security: [],
        licensing: [],
        documentation: [],
      },
      status: 'success',
    };

    try {
      // Security compliance
      results.compliance.security = await this.checkSecurityCompliance();

      // License compliance
      results.compliance.licensing = await this.checkLicenseCompliance();

      // Documentation compliance
      results.compliance.documentation = await this.checkDocumentationCompliance();

      // Evaluate overall compliance
      const issues = [
        ...results.compliance.security.filter(c => !c.compliant),
        ...results.compliance.licensing.filter(c => !c.compliant),
        ...results.compliance.documentation.filter(c => !c.compliant),
      ];

      if (issues.length > 0) {
        results.status = 'warning';
        this.logger.warn(`${issues.length} compliance issues found`);
      } else {
        this.logger.info('All compliance checks passed');
      }
    } catch (error) {
      this.logger.error('Compliance check failed', { error: error.message });
      results.status = 'failed';
      results.error = error.message;
    }

    return results;
  }

  // Helper methods

  async getImageSize(image) {
    try {
      const { stdout } = await execAsync(`docker inspect ${image} --format='{{.Size}}'`);
      return parseInt(stdout.trim());
    } catch {
      return null;
    }
  }

  async findFiles(pattern) {
    // Simple implementation - in production use glob
    const files = [];
    const searchDir = async dir => {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        if (['node_modules', '.git'].includes(entry.name)) continue;

        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          await searchDir(fullPath);
        } else if (this.matchesPattern(entry.name, pattern)) {
          files.push(fullPath);
        }
      }
    };

    await searchDir('.');
    return files;
  }

  matchesPattern(filename, pattern) {
    // Simple pattern matching
    const regex = pattern.replace(/\*/g, '.*').replace(/\./g, '\\.');
    return new RegExp(regex).test(filename);
  }

  async isFileGitignored(file) {
    try {
      const { stdout } = await execAsync(`git check-ignore ${file}`);
      return true;
    } catch {
      return false;
    }
  }

  async checkSecurityCompliance() {
    return [
      {
        requirement: 'No hardcoded secrets',
        compliant: true, // Will be set based on scan results
        severity: 'critical',
      },
      {
        requirement: 'Dependencies up to date',
        compliant: true,
        severity: 'high',
      },
      {
        requirement: 'Security headers configured',
        compliant: true,
        severity: 'medium',
      },
    ];
  }

  async checkLicenseCompliance() {
    return [
      {
        requirement: 'All dependencies have compatible licenses',
        compliant: true,
        severity: 'high',
      },
      {
        requirement: 'LICENSE file present',
        compliant: await fs
          .access('LICENSE')
          .then(() => true)
          .catch(() => false),
        severity: 'medium',
      },
    ];
  }

  async checkDocumentationCompliance() {
    return [
      {
        requirement: 'README.md present',
        compliant: await fs
          .access('README.md')
          .then(() => true)
          .catch(() => false),
        severity: 'medium',
      },
      {
        requirement: 'SECURITY.md present',
        compliant: await fs
          .access('SECURITY.md')
          .then(() => true)
          .catch(() => false),
        severity: 'medium',
      },
    ];
  }
}

module.exports = SecurityModule;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AgentOrchestratorModule.html">AgentOrchestratorModule</a></li><li><a href="MCPClient.html">MCPClient</a></li><li><a href="MCPModule.html">MCPModule</a></li><li><a href="MCPServer.html">MCPServer</a></li><li><a href="ResearchAgent.html">ResearchAgent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#WebSocket">WebSocket</a></li><li><a href="global.html#fs">fs</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Nov 22 2025 08:19:04 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
