<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: quality/code-quality-enforcer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: quality/code-quality-enforcer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Intelligent Code Quality Enforcement System
 * Ensures code quality standards are maintained across the repository
 */

const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const { EventEmitter } = require('events');

const execAsync = promisify(exec);

class CodeQualityEnforcer extends EventEmitter {
  constructor(config = {}) {
    super();

    this.config = {
      autoFix: config.autoFix !== false,
      strictMode: config.strictMode || false,
      thresholds: {
        complexity: config.complexityThreshold || 10,
        coverage: config.coverageThreshold || 80,
        duplication: config.duplicationThreshold || 5,
        maintainability: config.maintainabilityThreshold || 70
      },
      rules: {
        enforceJSDoc: true,
        enforceTypes: true,
        enforceNaming: true,
        enforceStructure: true,
        enforceTests: true
      },
      ...config
    };

    this.metrics = {
      lastCheck: null,
      issues: [],
      fixes: [],
      score: 0,
      trends: []
    };

    this.qualityGates = [
      'linting',
      'formatting',
      'typeChecking',
      'complexity',
      'coverage',
      'duplication',
      'security',
      'documentation'
    ];
    this.logger = config.logger || console;
  }

  async enforce() {
    this.logger.info('âš¡ Code Quality Enforcement Starting...');

    const results = {
      timestamp: new Date().toISOString(),
      passed: [],
      failed: [],
      fixed: [],
      score: 0
    };

    try {
      // Run quality gates
      for (const gate of this.qualityGates) {
        this.logger.info(`ðŸ” Checking ${gate}...`);
        const result = await this.runQualityGate(gate);

        if (result.passed) {
          results.passed.push(gate);
          this.logger.info(`  âœ… ${gate} passed`);
        } else {
          results.failed.push({ gate, issues: result.issues });
          this.logger.warn(`  âŒ ${gate} failed: ${result.issues.length} issues`);

          // Attempt auto-fix if enabled
          if (this.config.autoFix &amp;&amp; result.fixable) {
            const fixed = await this.autoFix(gate, result.issues);
            if (fixed.success) {
              results.fixed.push({ gate, count: fixed.count });
              this.logger.info(`    ðŸ”§ Fixed ${fixed.count} issues automatically`);
            }
          }
        }
      }

      // Calculate quality score
      results.score = this.calculateQualityScore(results);

      // Update metrics
      this.updateMetrics(results);

      // Generate report
      await this.generateReport(results);

      // Emit results
      this.emit('enforcementComplete', results);

      return results;

    } catch (error) {
      this.logger.error('Enforcement error:', error.message);
      this.emit('error', error);
      throw error;
    }
  }

  async runQualityGate(gate) {
    switch (gate) {
      case 'linting':
        return await this.checkLinting();
      case 'formatting':
        return await this.checkFormatting();
      case 'typeChecking':
        return await this.checkTypes();
      case 'complexity':
        return await this.checkComplexity();
      case 'coverage':
        return await this.checkCoverage();
      case 'duplication':
        return await this.checkDuplication();
      case 'security':
        return await this.checkSecurity();
      case 'documentation':
        return await this.checkDocumentation();
      default:
        return { passed: true, issues: [] };
    }
  }

  async checkLinting() {
    try {
      const { stdout, stderr } = await execAsync('npx eslint . --format json', {
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });

      if (stdout) {
        const results = JSON.parse(stdout);
        const issues = [];

        for (const file of results) {
          if (file.errorCount > 0 || file.warningCount > 0) {
            issues.push({
              file: file.filePath,
              errors: file.errorCount,
              warnings: file.warningCount,
              messages: file.messages
            });
          }
        }

        return {
          passed: issues.length === 0,
          issues,
          fixable: true
        };
      }

      return { passed: true, issues: [] };

    } catch (error) {
      // ESLint returns non-zero exit code when issues found
      if (error.stdout) {
        try {
          const results = JSON.parse(error.stdout);
          const issues = [];

          for (const file of results) {
            if (file.errorCount > 0 || (this.config.strictMode &amp;&amp; file.warningCount > 0)) {
              issues.push({
                file: file.filePath,
                errors: file.errorCount,
                warnings: file.warningCount
              });
            }
          }

          return {
            passed: false,
            issues,
            fixable: true
          };
        } catch {
          return { passed: false, issues: [{ error: 'Failed to parse ESLint output' }], fixable: false };
        }
      }

      return { passed: false, issues: [{ error: error.message }], fixable: false };
    }
  }

  async checkFormatting() {
    try {
      const { stdout } = await execAsync('npx prettier --check "**/*.{js,ts,jsx,tsx,json,md}"');
      return { passed: true, issues: [] };
    } catch (error) {
      // Prettier returns non-zero exit code when formatting issues found
      const unformattedFiles = error.stdout ? error.stdout.split('\n').filter(line => line.trim()) : [];
      return {
        passed: false,
        issues: unformattedFiles.map(file => ({ file, type: 'formatting' })),
        fixable: true
      };
    }
  }

  async checkTypes() {
    // Check if TypeScript is used
    try {
      await fs.access(path.join(process.cwd(), 'tsconfig.json'));
    } catch {
      return { passed: true, issues: [] }; // Skip if no TypeScript
    }

    try {
      const { stdout, stderr } = await execAsync('npx tsc --noEmit');
      return { passed: true, issues: [] };
    } catch (error) {
      const issues = error.stdout ?
        error.stdout.split('\n')
          .filter(line => line.includes('.ts'))
          .map(line => ({ error: line })) :
        [{ error: error.message }];

      return {
        passed: false,
        issues,
        fixable: false
      };
    }
  }

  async checkComplexity() {
    // Simplified complexity check
    // In production, use tools like es6-plato or complexity-report
    const complexFiles = [];

    try {
      const files = await this.findJavaScriptFiles();

      for (const file of files) {
        const content = await fs.readFile(file, 'utf8');
        const complexity = this.calculateCyclomaticComplexity(content);

        if (complexity > this.config.thresholds.complexity) {
          complexFiles.push({
            file,
            complexity,
            threshold: this.config.thresholds.complexity
          });
        }
      }

      return {
        passed: complexFiles.length === 0,
        issues: complexFiles,
        fixable: false
      };

    } catch (error) {
      return { passed: true, issues: [] };
    }
  }

  async checkCoverage() {
    try {
      const coveragePath = path.join(process.cwd(), 'coverage', 'coverage-summary.json');
      const coverage = JSON.parse(await fs.readFile(coveragePath, 'utf8'));

      const { total } = coverage;
      const avgCoverage = (
        total.lines.pct +
        total.statements.pct +
        total.functions.pct +
        total.branches.pct
      ) / 4;

      if (avgCoverage &lt; this.config.thresholds.coverage) {
        return {
          passed: false,
          issues: [{
            type: 'coverage',
            current: avgCoverage,
            threshold: this.config.thresholds.coverage,
            details: total
          }],
          fixable: false
        };
      }

      return { passed: true, issues: [] };

    } catch (error) {
      // Coverage not available
      return {
        passed: false,
        issues: [{ type: 'coverage', error: 'Coverage data not found. Run tests with coverage first.' }],
        fixable: false
      };
    }
  }

  async checkDuplication() {
    // Simplified duplication check
    // In production, use tools like jscpd
    try {
      const { stdout } = await execAsync('npx jscpd . --silent --format json');
      const results = JSON.parse(stdout);

      if (results.statistics.percentage > this.config.thresholds.duplication) {
        return {
          passed: false,
          issues: results.duplicates.map(dup => ({
            type: 'duplication',
            files: [dup.firstFile.name, dup.secondFile.name],
            lines: dup.lines
          })),
          fixable: false
        };
      }

      return { passed: true, issues: [] };

    } catch (error) {
      // Tool not available or no duplicates
      return { passed: true, issues: [] };
    }
  }

  async checkSecurity() {
    try {
      const { stdout } = await execAsync('npm audit --json');
      const audit = JSON.parse(stdout);

      if (audit.metadata.vulnerabilities.total > 0) {
        const issues = [];

        if (audit.metadata.vulnerabilities.critical > 0) {
          issues.push({ severity: 'critical', count: audit.metadata.vulnerabilities.critical });
        }
        if (audit.metadata.vulnerabilities.high > 0) {
          issues.push({ severity: 'high', count: audit.metadata.vulnerabilities.high });
        }
        if (this.config.strictMode &amp;&amp; audit.metadata.vulnerabilities.moderate > 0) {
          issues.push({ severity: 'moderate', count: audit.metadata.vulnerabilities.moderate });
        }

        return {
          passed: issues.length === 0,
          issues,
          fixable: true
        };
      }

      return { passed: true, issues: [] };

    } catch (error) {
      return { passed: true, issues: [] };
    }
  }

  async checkDocumentation() {
    const issues = [];

    try {
      // Check for missing documentation
      const requiredDocs = ['README.md', 'CONTRIBUTING.md', 'LICENSE'];

      for (const doc of requiredDocs) {
        try {
          await fs.access(path.join(process.cwd(), doc));
        } catch {
          issues.push({ type: 'missing', file: doc });
        }
      }

      // Check JSDoc coverage (simplified)
      if (this.config.rules.enforceJSDoc) {
        const files = await this.findJavaScriptFiles();

        for (const file of files.slice(0, 10)) { // Check first 10 files
          const content = await fs.readFile(file, 'utf8');
          const functions = content.match(/function\s+\w+|const\s+\w+\s*=\s*\(/g) || [];
          const jsdocs = content.match(/\/\*\*[\s\S]*?\*\//g) || [];

          if (functions.length > jsdocs.length) {
            issues.push({
              type: 'jsdoc',
              file,
              functions: functions.length,
              documented: jsdocs.length
            });
          }
        }
      }

      return {
        passed: issues.length === 0,
        issues,
        fixable: false
      };

    } catch (error) {
      return { passed: true, issues: [] };
    }
  }

  async autoFix(gate, issues) {
    try {
      let fixed = 0;

      switch (gate) {
        case 'linting':
          await execAsync('npx eslint . --fix');
          fixed = issues.length; // Assume all fixable issues are fixed
          break;

        case 'formatting':
          await execAsync('npx prettier --write "**/*.{js,ts,jsx,tsx,json,md}"');
          fixed = issues.length;
          break;

        case 'security':
          await execAsync('npm audit fix');
          fixed = issues.filter(i => i.severity !== 'critical').length;
          break;

        default:
          return { success: false, count: 0 };
      }

      return { success: true, count: fixed };

    } catch (error) {
      return { success: false, count: 0, error: error.message };
    }
  }

  calculateQualityScore(results) {
    const totalGates = this.qualityGates.length;
    const passedGates = results.passed.length;
    const fixedGates = results.fixed.length;

    // Base score from passed gates
    let score = (passedGates / totalGates) * 100;

    // Bonus for auto-fixes
    score += (fixedGates / totalGates) * 10;

    // Penalties for critical failures
    const criticalGates = ['security', 'typeChecking'];
    const failedCritical = results.failed.filter(f => criticalGates.includes(f.gate));
    score -= failedCritical.length * 20;

    return Math.max(0, Math.min(100, Math.round(score)));
  }

  updateMetrics(results) {
    this.metrics.lastCheck = results.timestamp;
    this.metrics.issues = results.failed;
    this.metrics.fixes = results.fixed;
    this.metrics.score = results.score;

    // Track trends
    this.metrics.trends.push({
      timestamp: results.timestamp,
      score: results.score,
      issues: results.failed.length
    });

    // Keep only last 100 trends
    if (this.metrics.trends.length > 100) {
      this.metrics.trends.shift();
    }
  }

  async generateReport(results) {
    const report = {
      ...results,
      summary: {
        qualityScore: results.score,
        gates: {
          total: this.qualityGates.length,
          passed: results.passed.length,
          failed: results.failed.length,
          fixed: results.fixed.length
        },
        recommendation: this.getRecommendation(results.score)
      }
    };

    // Save report
    const reportPath = path.join(process.cwd(), '.automation', 'quality', 'reports');
    await fs.mkdir(reportPath, { recursive: true });
    await fs.writeFile(
      path.join(reportPath, `quality-report-${Date.now()}.json`),
      JSON.stringify(report, null, 2)
    );

    this.logger.info('ðŸ“Š Code Quality Report');
    this.logger.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    this.logger.info(`Quality Score: ${results.score}/100`);
    this.logger.info(`Gates Passed: ${results.passed.length}/${this.qualityGates.length}`);
    if (results.fixed.length > 0) {
      this.logger.info(`Auto-fixed: ${results.fixed.reduce((sum, f) => sum + f.count, 0)} issues`);
    }
    this.logger.info(`Recommendation: ${report.summary.recommendation}`);
  }

  getRecommendation(score) {
    if (score >= 90) return 'ðŸŒŸ Excellent! Code quality is outstanding.';
    if (score >= 80) return 'âœ… Good! Minor improvements recommended.';
    if (score >= 70) return 'âš ï¸ Fair. Several quality issues need attention.';
    if (score >= 60) return 'âš ï¸ Poor. Significant quality improvements needed.';
    return 'âŒ Critical. Immediate quality improvements required.';
  }

  // Helper methods

  async findJavaScriptFiles() {
    const files = [];

    const scanDir = async (dir) => {
      try {
        const entries = await fs.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
          if (entry.name === 'node_modules' || entry.name === '.git') continue;

          const fullPath = path.join(dir, entry.name);

          if (entry.isDirectory()) {
            await scanDir(fullPath);
          } else if (entry.isFile() &amp;&amp; /\.(js|ts|jsx|tsx)$/.test(entry.name)) {
            files.push(fullPath);
          }
        }
      } catch {
        // Ignore inaccessible directories
      }
    };

    await scanDir(process.cwd());
    return files;
  }

  calculateCyclomaticComplexity(code) {
    // Simplified complexity calculation
    const patterns = [
      /if\s*\(/g,
      /else\s+if\s*\(/g,
      /for\s*\(/g,
      /while\s*\(/g,
      /case\s+/g,
      /catch\s*\(/g,
      /\?\s*.*\s*:/g // ternary operators
    ];

    let complexity = 1; // Base complexity

    for (const pattern of patterns) {
      const matches = code.match(pattern);
      if (matches) {
        complexity += matches.length;
      }
    }

    return complexity;
  }

  getMetrics() {
    return this.metrics;
  }

  async monitor() {
    this.logger.info('ðŸ“Š Starting continuous code quality monitoring...');

    // Run initial check
    await this.enforce();

    // Set up periodic checks
    setInterval(async () => {
      await this.enforce();
    }, 300000); // Every 5 minutes

    this.emit('monitoringStarted');
  }
}

// Run if executed directly
if (require.main === module) {
  const enforcer = new CodeQualityEnforcer({
    autoFix: true,
    strictMode: false
  });

  enforcer.on('enforcementComplete', (results) => {
    enforcer.logger.info('âœ… Code quality enforcement complete');
  });

  enforcer.on('error', (error) => {
    enforcer.logger.error('âŒ Enforcement error:', error.message);
  });

  enforcer.enforce().catch(err => enforcer.logger.error(err.message));
}

module.exports = CodeQualityEnforcer;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AgentOrchestratorModule.html">AgentOrchestratorModule</a></li><li><a href="MCPClient.html">MCPClient</a></li><li><a href="MCPModule.html">MCPModule</a></li><li><a href="MCPServer.html">MCPServer</a></li><li><a href="ResearchAgent.html">ResearchAgent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#WebSocket">WebSocket</a></li><li><a href="global.html#fs">fs</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Nov 22 2025 08:19:04 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
