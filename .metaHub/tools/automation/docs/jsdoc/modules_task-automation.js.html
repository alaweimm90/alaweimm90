<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/task-automation.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/task-automation.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Task Automation Module
 * Provides automated task execution capabilities
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const { BaseModule } = require('../core/framework');

const execAsync = promisify(exec);

class TaskAutomationModule extends BaseModule {
  constructor(framework) {
    super(framework);
    this.name = 'task-automation';

    // Register tasks
    this.registerTask('run-script', this.runScript);
    this.registerTask('clean-directories', this.cleanDirectories);
    this.registerTask('backup-files', this.backupFiles);
    this.registerTask('generate-report', this.generateReport);
    this.registerTask('run-tests', this.runTests);
  }

  async init() {
    await super.init();
    this.logger.info('Task Automation Module initialized');
  }

  /**
   * Run a script or command
   * @param {{command:string,cwd?:string,timeout?:number}} params Command options
   * @returns {Promise&lt;{command:string,stdout?:string,stderr?:string,success:boolean,timestamp:string,error?:string}>}
   */
  async runScript(params = {}) {
    const { command, cwd = process.cwd(), timeout = 30000 } = params;

    if (!command) {
      throw new Error('Command is required');
    }

    this.logger.info(`Running script: ${command}`);

    try {
      const { stdout, stderr } = await execAsync(command, {
        cwd,
        timeout,
      });

      const result = {
        command,
        stdout: stdout.trim(),
        stderr: stderr.trim(),
        success: true,
        timestamp: new Date().toISOString(),
      };

      this.logger.info('Script executed successfully');
      return result;
    } catch (error) {
      this.logger.error(`Script execution failed: ${error.message}`);
      return {
        command,
        error: error.message,
        success: false,
        timestamp: new Date().toISOString(),
      };
    }
  }

  /**
   * Clean specified directories
   * @param {{directories?:string[],dryRun?:boolean}} params Clean options
   * @returns {Promise&lt;{cleaned:Array,failed:Array,totalSize:number,totalFiles:number}>}
   */
  async cleanDirectories(params = {}) {
    const {
      directories = ['dist', 'build', '.cache', 'tmp'],
      dryRun = false,
    } = params;

    this.logger.info(`Cleaning directories: ${directories.join(', ')}${dryRun ? ' (dry run)' : ''}`);

    const results = {
      cleaned: [],
      failed: [],
      totalSize: 0,
      totalFiles: 0,
    };

    for (const dir of directories) {
      const dirPath = path.join(process.cwd(), dir);

      try {
        const exists = await fs.access(dirPath).then(() => true).catch(() => false);

        if (exists) {
          const stats = await this.getDirectoryStats(dirPath);
          results.totalSize += stats.size;
          results.totalFiles += stats.files;

          if (!dryRun) {
            await this.removeDirectory(dirPath);
          }

          results.cleaned.push({
            path: dir,
            size: stats.size,
            files: stats.files,
          });

          this.logger.info(`Cleaned: ${dir} (${stats.files} files, ${this.formatBytes(stats.size)})`);
        }
      } catch (error) {
        results.failed.push({
          path: dir,
          error: error.message,
        });
        this.logger.error(`Failed to clean ${dir}: ${error.message}`);
      }
    }

    return results;
  }

  /**
   * Backup specified files or directories
   * @param {{sources:string[],destination?:string,timestamp?:boolean}} params Backup options
   * @returns {Promise&lt;{backed_up:Array,failed:Array,totalSize:number}>}
   */
  async backupFiles(params = {}) {
    const {
      sources = [],
      destination = '.backup',
      timestamp = true,
    } = params;

    if (sources.length === 0) {
      throw new Error('No sources specified for backup');
    }

    const backupDir = timestamp
      ? path.join(destination, new Date().toISOString().replace(/:/g, '-'))
      : destination;

    this.logger.info(`Creating backup in ${backupDir}`);

    // Create backup directory
    await fs.mkdir(backupDir, { recursive: true });

    const results = {
      backed_up: [],
      failed: [],
      totalSize: 0,
    };

    for (const source of sources) {
      const sourcePath = path.join(process.cwd(), source);
      const destPath = path.join(backupDir, path.basename(source));

      try {
        await this.copyRecursive(sourcePath, destPath);
        const stats = await fs.stat(sourcePath);

        results.backed_up.push({
          source,
          destination: destPath,
          size: stats.size,
        });

        results.totalSize += stats.size;
        this.logger.info(`Backed up: ${source}`);
      } catch (error) {
        results.failed.push({
          source,
          error: error.message,
        });
        this.logger.error(`Failed to backup ${source}: ${error.message}`);
      }
    }

    return results;
  }

  /**
   * Generate automation report
   * @param {{outputPath?:string}} params Output path
   * @returns {Promise&lt;object>}
   */
  async generateReport(params = {}) {
    const { outputPath = '.automation/reports/automation-report.json' } = params;

    this.logger.info('Generating automation report');

    const report = {
      timestamp: new Date().toISOString(),
      framework: {
        version: this.framework.config.version,
        uptime: process.uptime(),
        modules: Array.from(this.framework.modules.keys()),
        plugins: Array.from(this.framework.plugins.keys()),
      },
      metrics: this.framework.metrics,
      health: this.framework.getHealthStatus(),
      recentTasks: [],
    };

    // Ensure report directory exists
    const reportDir = path.dirname(outputPath);
    await fs.mkdir(reportDir, { recursive: true });

    // Write report
    await fs.writeFile(outputPath, JSON.stringify(report, null, 2));

    this.logger.info(`Report generated: ${outputPath}`);
    return report;
  }

  /**
   * Run tests
   * @param {{testCommand?:string,coverage?:boolean}} params Test options
   * @returns {Promise&lt;{command:string,output?:string,errors?:string,success:boolean,timestamp:string,error?:string}>}
   */
  async runTests(params = {}) {
    const { testCommand = 'npm test', coverage = false } = params;

    const command = coverage ? 'npm run test:coverage' : testCommand;

    this.logger.info(`Running tests: ${command}`);

    try {
      const { stdout, stderr } = await execAsync(command);

      // Parse test results if possible
      const results = {
        command,
        output: stdout,
        errors: stderr,
        success: !stderr.includes('FAIL'),
        timestamp: new Date().toISOString(),
      };

      if (results.success) {
        this.logger.info('Tests passed successfully');
      } else {
        this.logger.warn('Some tests failed');
      }

      return results;
    } catch (error) {
      this.logger.error(`Test execution failed: ${error.message}`);
      return {
        command,
        error: error.message,
        success: false,
        timestamp: new Date().toISOString(),
      };
    }
  }

  // Helper methods

  async getDirectoryStats(dirPath) {
    let totalSize = 0;
    let totalFiles = 0;

    const processDir = async (dir) => {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          await processDir(fullPath);
        } else {
          const stats = await fs.stat(fullPath);
          totalSize += stats.size;
          totalFiles++;
        }
      }
    };

    await processDir(dirPath);
    return { size: totalSize, files: totalFiles };
  }

  async removeDirectory(dirPath) {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);

      if (entry.isDirectory()) {
        await this.removeDirectory(fullPath);
      } else {
        await fs.unlink(fullPath);
      }
    }

    await fs.rmdir(dirPath);
  }

  async copyRecursive(src, dest) {
    const stats = await fs.stat(src);

    if (stats.isDirectory()) {
      await fs.mkdir(dest, { recursive: true });
      const entries = await fs.readdir(src);

      for (const entry of entries) {
        await this.copyRecursive(
          path.join(src, entry),
          path.join(dest, entry)
        );
      }
    } else {
      await fs.copyFile(src, dest);
    }
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / k**i).toFixed(2))  } ${  sizes[i]}`;
  }
}

module.exports = TaskAutomationModule;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AgentOrchestratorModule.html">AgentOrchestratorModule</a></li><li><a href="MCPClient.html">MCPClient</a></li><li><a href="MCPModule.html">MCPModule</a></li><li><a href="MCPServer.html">MCPServer</a></li><li><a href="ResearchAgent.html">ResearchAgent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#WebSocket">WebSocket</a></li><li><a href="global.html#fs">fs</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Nov 22 2025 08:19:04 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
