#!/usr/bin/env npx tsx
/**
 * AI Issue Management System
 * Automated issue creation, tracking, and remediation
 */

import * as path from 'path';
import { execSync } from 'child_process';
import { loadJson, saveJson } from './utils/file-persistence.js';

const ROOT = process.cwd();
const AI_DIR = path.join(ROOT, '.ai');
const ISSUES_FILE = path.join(AI_DIR, 'issues.json');

// ============================================================================
// Types
// ============================================================================

type IssuePriority = 'critical' | 'high' | 'medium' | 'low';
type IssueStatus = 'open' | 'in_progress' | 'resolved' | 'wont_fix';
type IssueCategory =
  | 'security'
  | 'compliance'
  | 'performance'
  | 'bug'
  | 'enhancement'
  | 'maintenance';

interface AIIssue {
  id: string;
  timestamp: string;
  category: IssueCategory;
  priority: IssuePriority;
  status: IssueStatus;
  title: string;
  description: string;
  source: string;
  labels: string[];
  assignee?: string;
  githubIssue?: number;
  relatedFiles: string[];
  remediationSteps: string[];
  dueDate?: string;
  resolvedAt?: string;
  resolution?: string;
}

interface IssueTemplate {
  category: IssueCategory;
  titleTemplate: string;
  descriptionTemplate: string;
  defaultLabels: string[];
  defaultPriority: IssuePriority;
  remediationSteps: string[];
}

interface IssueStats {
  total: number;
  open: number;
  resolved: number;
  byCategory: Record<IssueCategory, number>;
  byPriority: Record<IssuePriority, number>;
  avgResolutionTime: number;
}

interface IssueState {
  issues: AIIssue[];
  stats: IssueStats;
}

// ============================================================================
// Issue Templates
// ============================================================================

const ISSUE_TEMPLATES: Record<string, IssueTemplate> = {
  security_vulnerability: {
    category: 'security',
    titleTemplate: 'üö® Security: {title}',
    descriptionTemplate: `## Security Issue

**Severity:** {priority}
**Source:** {source}

### Description
{description}

### Affected Files
{files}

### Remediation
{remediation}

---
*Auto-generated by AI Issue Management*`,
    defaultLabels: ['security', 'automated'],
    defaultPriority: 'high',
    remediationSteps: [
      'Review the affected code',
      'Apply recommended fix',
      'Run security scan to verify',
      'Update dependencies if needed',
    ],
  },
  compliance_violation: {
    category: 'compliance',
    titleTemplate: 'üìã Compliance: {title}',
    descriptionTemplate: `## Compliance Issue

**Rule:** {rule}
**Score Impact:** {impact}

### Description
{description}

### Affected Files
{files}

### Required Actions
{remediation}

---
*Auto-generated by AI Compliance System*`,
    defaultLabels: ['compliance', 'automated'],
    defaultPriority: 'medium',
    remediationSteps: [
      'Review compliance rule',
      'Update code to meet requirements',
      'Run compliance check',
      'Request review if needed',
    ],
  },
  performance_issue: {
    category: 'performance',
    titleTemplate: '‚ö° Performance: {title}',
    descriptionTemplate: `## Performance Issue

**Metric:** {metric}
**Current:** {current}
**Target:** {target}

### Description
{description}

### Optimization Steps
{remediation}

---
*Auto-generated by AI Monitor*`,
    defaultLabels: ['performance', 'automated'],
    defaultPriority: 'medium',
    remediationSteps: [
      'Profile the affected code',
      'Identify bottlenecks',
      'Apply optimizations',
      'Verify improvements',
    ],
  },
  maintenance_task: {
    category: 'maintenance',
    titleTemplate: 'üîß Maintenance: {title}',
    descriptionTemplate: `## Maintenance Task

**Type:** {type}

### Description
{description}

### Tasks
{remediation}

---
*Auto-generated by AI Orchestrator*`,
    defaultLabels: ['maintenance', 'automated'],
    defaultPriority: 'low',
    remediationSteps: ['Review the task', 'Execute maintenance steps', 'Verify completion'],
  },
};

// ============================================================================
// Issue Manager Implementation
// ============================================================================

class IssueManager {
  private state: IssueState;

  constructor() {
    this.state = this.loadState();
  }

  private loadState(): IssueState {
    const defaultState: IssueState = {
      issues: [],
      stats: {
        total: 0,
        open: 0,
        resolved: 0,
        byCategory: {
          security: 0,
          compliance: 0,
          performance: 0,
          bug: 0,
          enhancement: 0,
          maintenance: 0,
        },
        byPriority: {
          critical: 0,
          high: 0,
          medium: 0,
          low: 0,
        },
        avgResolutionTime: 0,
      },
    };

    return loadJson<IssueState>(ISSUES_FILE, defaultState) ?? defaultState;
  }

  private saveState(): void {
    saveJson(ISSUES_FILE, this.state);
  }

  private generateId(): string {
    return `issue-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
  }

  private updateStats(): void {
    const issues = this.state.issues;
    this.state.stats = {
      total: issues.length,
      open: issues.filter((i) => i.status === 'open' || i.status === 'in_progress').length,
      resolved: issues.filter((i) => i.status === 'resolved').length,
      byCategory: {
        security: issues.filter((i) => i.category === 'security').length,
        compliance: issues.filter((i) => i.category === 'compliance').length,
        performance: issues.filter((i) => i.category === 'performance').length,
        bug: issues.filter((i) => i.category === 'bug').length,
        enhancement: issues.filter((i) => i.category === 'enhancement').length,
        maintenance: issues.filter((i) => i.category === 'maintenance').length,
      },
      byPriority: {
        critical: issues.filter((i) => i.priority === 'critical').length,
        high: issues.filter((i) => i.priority === 'high').length,
        medium: issues.filter((i) => i.priority === 'medium').length,
        low: issues.filter((i) => i.priority === 'low').length,
      },
      avgResolutionTime: this.calculateAvgResolutionTime(),
    };
  }

  private calculateAvgResolutionTime(): number {
    const resolved = this.state.issues.filter((i) => i.status === 'resolved' && i.resolvedAt);
    if (resolved.length === 0) return 0;

    const totalHours = resolved.reduce((sum, issue) => {
      const created = new Date(issue.timestamp).getTime();
      const resolvedTime = new Date(issue.resolvedAt!).getTime();
      return sum + (resolvedTime - created) / (1000 * 60 * 60);
    }, 0);

    return Math.round(totalHours / resolved.length);
  }

  // Create a new issue
  create(options: {
    category: IssueCategory;
    title: string;
    description: string;
    source: string;
    priority?: IssuePriority;
    labels?: string[];
    relatedFiles?: string[];
    remediationSteps?: string[];
  }): AIIssue {
    const template = Object.values(ISSUE_TEMPLATES).find((t) => t.category === options.category);

    const issue: AIIssue = {
      id: this.generateId(),
      timestamp: new Date().toISOString(),
      category: options.category,
      priority: options.priority || template?.defaultPriority || 'medium',
      status: 'open',
      title: options.title,
      description: options.description,
      source: options.source,
      labels: [...(template?.defaultLabels || []), ...(options.labels || [])],
      relatedFiles: options.relatedFiles || [],
      remediationSteps: options.remediationSteps || template?.remediationSteps || [],
    };

    this.state.issues.push(issue);
    this.updateStats();
    this.saveState();

    return issue;
  }

  // Create from template
  createFromTemplate(
    templateKey: string,
    variables: Record<string, string>,
    options: { priority?: IssuePriority; relatedFiles?: string[] } = {}
  ): AIIssue | null {
    const template = ISSUE_TEMPLATES[templateKey];
    if (!template) return null;

    let title = template.titleTemplate;
    let description = template.descriptionTemplate;

    for (const [key, value] of Object.entries(variables)) {
      title = title.replace(`{${key}}`, value);
      description = description.replace(`{${key}}`, value);
    }

    return this.create({
      category: template.category,
      title,
      description,
      source: templateKey,
      priority: options.priority || template.defaultPriority,
      labels: template.defaultLabels,
      relatedFiles: options.relatedFiles,
      remediationSteps: template.remediationSteps,
    });
  }

  // Update issue status
  updateStatus(issueId: string, status: IssueStatus, resolution?: string): boolean {
    const issue = this.state.issues.find((i) => i.id === issueId);
    if (!issue) return false;

    issue.status = status;
    if (status === 'resolved') {
      issue.resolvedAt = new Date().toISOString();
      issue.resolution = resolution;
    }

    this.updateStats();
    this.saveState();
    return true;
  }

  // Get open issues
  getOpen(category?: IssueCategory): AIIssue[] {
    return this.state.issues.filter(
      (i) =>
        (i.status === 'open' || i.status === 'in_progress') &&
        (!category || i.category === category)
    );
  }

  // Get by priority
  getByPriority(priority: IssuePriority): AIIssue[] {
    return this.state.issues.filter((i) => i.priority === priority && i.status !== 'resolved');
  }

  // Get stats
  getStats(): IssueStats {
    return { ...this.state.stats };
  }

  // Get issue by ID
  get(issueId: string): AIIssue | undefined {
    return this.state.issues.find((i) => i.id === issueId);
  }

  // Link to GitHub issue
  linkGitHubIssue(issueId: string, githubNumber: number): boolean {
    const issue = this.state.issues.find((i) => i.id === issueId);
    if (!issue) return false;

    issue.githubIssue = githubNumber;
    this.saveState();
    return true;
  }

  // Create GitHub issue via gh CLI
  createGitHubIssue(issueId: string): number | null {
    const issue = this.state.issues.find((i) => i.id === issueId);
    if (!issue) return null;

    try {
      const labels = issue.labels.join(',');
      const body = `${issue.description}\n\n---\n**AI Issue ID:** ${issue.id}\n**Priority:** ${issue.priority}`;

      const result = execSync(
        `gh issue create --title "${issue.title}" --body "${body.replace(/"/g, '\\"')}" --label "${labels}"`,
        { encoding: 'utf8', cwd: ROOT }
      );

      // Extract issue number from URL
      const match = result.match(/issues\/(\d+)/);
      if (match) {
        const ghNumber = parseInt(match[1]);
        this.linkGitHubIssue(issueId, ghNumber);
        return ghNumber;
      }
    } catch {
      // gh CLI not available or failed
    }

    return null;
  }

  // Auto-create issues from findings
  createFromFindings(
    findings: Array<{
      type: string;
      severity: string;
      description: string;
      file?: string;
      recommendation?: string;
    }>
  ): AIIssue[] {
    const created: AIIssue[] = [];

    // Group by type
    const byType = findings.reduce(
      (acc, f) => {
        const key = f.type;
        if (!acc[key]) acc[key] = [];
        acc[key].push(f);
        return acc;
      },
      {} as Record<string, typeof findings>
    );

    for (const [type, items] of Object.entries(byType)) {
      const severity = items.some((i) => i.severity === 'critical')
        ? 'critical'
        : items.some((i) => i.severity === 'high')
          ? 'high'
          : 'medium';

      const files = items.filter((i) => i.file).map((i) => i.file!);
      const descriptions = items.map((i) => `- ${i.description}`).join('\n');

      let category: IssueCategory = 'maintenance';
      if (type === 'secret' || type === 'vulnerability') category = 'security';
      else if (type === 'license') category = 'compliance';
      else if (type === 'sensitive-file') category = 'security';

      const issue = this.create({
        category,
        title: `${items.length} ${type} finding(s) detected`,
        description: `### Findings\n${descriptions}`,
        source: 'security-scanner',
        priority: severity as IssuePriority,
        relatedFiles: files,
      });

      created.push(issue);
    }

    return created;
  }
}

// ============================================================================
// Singleton Export
// ============================================================================

export const issueManager = new IssueManager();

// ============================================================================
// CLI Interface
// ============================================================================

function displayIssues(issues: AIIssue[]): void {
  if (issues.length === 0) {
    console.log('\n‚úÖ No issues to display\n');
    return;
  }

  console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë            üìã AI ISSUE TRACKER                               ‚ïë');
  console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');

  for (const issue of issues.slice(0, 10)) {
    const icon =
      issue.priority === 'critical'
        ? 'üî¥'
        : issue.priority === 'high'
          ? 'üü†'
          : issue.priority === 'medium'
            ? 'üü°'
            : 'üîµ';
    const status =
      issue.status === 'resolved' ? '‚úÖ' : issue.status === 'in_progress' ? 'üîÑ' : 'üìå';

    console.log('‚ïë                                                              ‚ïë');
    console.log(`‚ïë  ${icon} ${issue.title.substring(0, 45)}...`.padEnd(65) + '‚ïë');
    console.log(`‚ïë     ID: ${issue.id} | Status: ${status}`.padEnd(65) + '‚ïë');
    console.log(`‚ïë     Category: ${issue.category} | Source: ${issue.source}`.padEnd(65) + '‚ïë');
    if (issue.githubIssue) {
      console.log(`‚ïë     GitHub: #${issue.githubIssue}`.padEnd(65) + '‚ïë');
    }
  }

  if (issues.length > 10) {
    console.log('‚ïë                                                              ‚ïë');
    console.log(`‚ïë  ... and ${issues.length - 10} more issues`.padEnd(65) + '‚ïë');
  }

  console.log('‚ïë                                                              ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
}

function main(): void {
  const args = process.argv.slice(2);
  const command = args[0];

  switch (command) {
    case 'list':
    case 'open': {
      const category = args[1] as IssueCategory | undefined;
      const issues = issueManager.getOpen(category);
      displayIssues(issues);
      break;
    }

    case 'critical': {
      const issues = issueManager.getByPriority('critical');
      displayIssues(issues);
      break;
    }

    case 'stats': {
      const stats = issueManager.getStats();
      console.log('\nüìä Issue Statistics\n');
      console.log(`Total Issues: ${stats.total}`);
      console.log(`Open: ${stats.open}`);
      console.log(`Resolved: ${stats.resolved}`);
      console.log(`Avg Resolution Time: ${stats.avgResolutionTime}h`);
      console.log('\nBy Category:');
      for (const [cat, count] of Object.entries(stats.byCategory)) {
        if (count > 0) console.log(`  ${cat}: ${count}`);
      }
      console.log('\nBy Priority:');
      for (const [pri, count] of Object.entries(stats.byPriority)) {
        if (count > 0) console.log(`  ${pri}: ${count}`);
      }
      break;
    }

    case 'create': {
      const category = (args[1] as IssueCategory) || 'maintenance';
      const title = args.slice(2).join(' ') || 'New Issue';
      const issue = issueManager.create({
        category,
        title,
        description: 'Created via CLI',
        source: 'cli',
      });
      console.log(`\n‚úÖ Created issue: ${issue.id}\n`);
      break;
    }

    case 'resolve': {
      const issueId = args[1];
      const resolution = args.slice(2).join(' ') || 'Resolved';
      if (issueId) {
        const resolved = issueManager.updateStatus(issueId, 'resolved', resolution);
        console.log(resolved ? `\n‚úÖ Issue ${issueId} resolved\n` : `\n‚ùå Issue not found\n`);
      } else {
        console.log('Usage: issues resolve <issue-id> [resolution]');
      }
      break;
    }

    case 'gh-create': {
      const issueId = args[1];
      if (issueId) {
        const ghNumber = issueManager.createGitHubIssue(issueId);
        if (ghNumber) {
          console.log(`\n‚úÖ Created GitHub issue #${ghNumber}\n`);
        } else {
          console.log('\n‚ùå Failed to create GitHub issue\n');
        }
      } else {
        console.log('Usage: issues gh-create <issue-id>');
      }
      break;
    }

    default:
      console.log(`
AI Issue Manager - Automated issue tracking

Commands:
  list [category]     List open issues
  critical            List critical priority issues
  stats               Show issue statistics
  create <cat> <title> Create new issue
  resolve <id> [msg]  Resolve an issue
  gh-create <id>      Create GitHub issue from AI issue

Categories: security, compliance, performance, bug, enhancement, maintenance
      `);
  }
}

main();
